<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../css/style.css" rel="stylesheet">
    <script type="module" src="../rootNavBar.js"></script>
    <script type="module" src='../databases/databaseNavBar.js'></script>
    <title>Normalisation</title>
</head>
<body>
    <root-nav-bar current='Databases' relative="../"></root-nav-bar>
    <database-nav-bar current="Normalisation" relative="../databases/"></database-nav-bar>
    <main>
        <h1>Normalisation</h1>
        <p>
            A process of organising data in the database.
            This is used to reduce duplication and improve data integrity.
            This process is one of iterative improvement illustrated below.
            We will continue to use the existing example and illustrate using 
            Crow's Foot notation ERD.
        </p>
        <h2>First Normal Form (1NF)</h2>
        <div>
            This is the first step in normalisation.
            You must ensure that all attributes <b>depend on the key</b>.
            This also means you should not:
            <ul>
                <li>Depend on the row's order</li>
                <li>Mix data types in one attribute</li>
                <li>Have any attribute that is not atomic (single valued)</li>
                <li>Have tables without a Primary Key</li>
                <li>Repeat rows</li>
            </ul>
        </div>
        <p class="warn">
            I have mentioned that "Personal ID" are autogenerated numbers.
            Most DBMS will simply generate number from 1 and increase it by 1.
            Therefore row 1 will have ID 1 and row 2 will have ID 2.
            This does not mean we depend on the row's order.
            If we delete row 2 then "Personal ID" of 2 is deleted.
            Or if we changed the order of the rows so "Personal ID" of 1 was the last row.
            Then we don't have any issues because we depend on the "Personal ID",
            even if it is simply an increasing number.
        </p>
        <h3>Depends on the Key</h3>
        <div>
            How does this relate to the list that the table should not do?
            <ul>
                <li>If it depended on the row's order then it does not depend on the key.</li>
                <li>
                    If it has mixed data type in an attribute, then it's not going to be a valid column.
                    If for example for PEOPLE we include "wealth" and sometimes we said the money they had
                    as a value "10000.00" and othertimes as text "minted".  Then the attribute may no longer 
                    be atomic but more importantly we can't have a column of (INT or VARCHAR) type.
                </li>
                <li>
                    If we have non-atomic data like History then it's values don't depend on the key.
                    The history of the friendship does depend Friend ID. 
                    So if we stored this simply as a text explanation of the history then it's okay.
                    But instead we want to store multiple values in this column.
                    Each value depends on the history of the friendship and so only indirectly on the key.
                </li>
                <li>If we have no Primary Key then we don't have a way to depend on it</li>
                <li>
                    If we have repeated rows then we have data that does not depend on the key.
                    For example we could have stored multiple entries for friends - one for each 
                    friend update.  However again, the friend update information does not depend on
                    Friend ID directly but on the history of friendship.
                </li>
            </ul>
            <div class="eg">
                We now know that our data is not in 1NF mainly because of FRIENDS table, History attribute.
                Therefore we will migrate this to an associative entity like Attendees.
                Both Attendees and Updates will also have their key made more explicit.<br/><br/>
                <img src="../assets/databases/1nf.jpg" alt="Example in 1NF"><br/><br/>
                I've separated the candidate keys from the normal attributes.
                The following relationships therefore exist:
                <ol>
                    <li>
                        Attendee is linked by Event and Person Name to, respectively EVENTS and PEOPLE table.
                        We've decided that our unique primary key is a composite of these foreign keys.
                        This is fairly common in associated entities.
                        Some prefer to have an explicit "Attendees ID" instead to avoid composite keys.
                    </li>
                    <li>
                        PEOPLE and FRIENDS both have their own unique primary key "Personal ID" and "Friend ID".
                        They are however linked via a secondary key i.e. the person's name.
                    </li>
                    <li>
                        FRIENDS are linked the UPDATES via the secondary key name.
                        Whilst UPDATES primary key is a composite of Name and "Updated At".
                        Again we could opt for an explicity "Update ID" instead.
                    </li>
                </ol>
                <p class="danger">
                    The above looks all okay as we now "depend on the key".
                    However it is worth stressing that this should also apply the relationships.
                    In many cases we are relying upon the "Name" secondary key.
                    However the KEY that matter is the Primary Key.
                    Why don't we say "It depends on the primary key" ... You'll discover that at the end of normalisation!
                    So we need to correct the example to ensure it depends on the PRIMARY KEY.
                </p>
                Now we will correct the key to always use the PRIMARY KEY.<br/><br/>
                <img src="../assets/databases/1nf_pk.jpg" alt="Example in 1NF"><br/><br/>
                <br />
                Now we're no longer distracted by the secondary key.
                We can now see that we've forgot something, namely every attribute should depend on the key.
                So let us re-examine our attributes:
                <ul>
                    <li>EVENTS Name depends on Event ID</li>
                    <li>EVENTS Start Date depends on Event ID</li>
                    <li>EVENTS Location depends on Event ID</li>
                    <li>ATTENDEES Is Friend? does NOT depend on Personal ID</li>
                    <li>ATTENDEES Age depends on Personal ID</li>
                    <li>PEOPLE Name depends on Personal ID</li>
                    <li>PEOPLE DoB depends on Personal ID</li>
                    <li>PEOPLE Gender depends on Personal ID</li>
                    <li>PEOPLE Is Friend Now? does NOT depend on Personal ID</li>
                    <li>PEOPLE Is Last IFN does NOT depend on Personal ID</li>
                    <li>FRIENDS Personal ID depends on Friend ID</li>
                    <li>FRIENDS Last Added depends on Friend ID</li>
                    <li>FRIENDS Is Friend Now? depends on Friend ID</li>
                    <li>UPDATES Friend ID depends on Update ID</li>
                    <li>UPDATES Updated At depends on Update ID</li>
                    <li>UPDATES Is Friend? depends on Update ID</li>
                    <li>UPDATES Reason For Update depends on Update ID</li>
                </ul>
                We can see that we have three attributes in the database that do not rely upon the primary key.
                These attributes all relate to FRIENDS and Friend ID but are in ATTENDEES and PEOPLE tables.
                We therefore need to remove these to ensure it is in 1NF.
                Please note that "Last Added" and "Is Friend Now?" in FRIENDS can be inferred by UPDATES.
                However they still depend on the primary key so you can keep them for 1NF, 2NF and 3NF.
                Yet the FRIENDS table now looks a bit redundant so I've decided to eliminated it.
                If you can think of attribute that apply only to FRIENDS and not PEOPLE or UPDATES then definitely keep it.<br/><br/>
                <img src="../assets/databases/1nf_correct.jpg" alt="Example in 1NF"><br/><br/>
            </div>
        </div>
        <h2>Second Normal Form (2NF)</h2>
        <p>
            This is the second step in normalisation.
            You must ensure it is in 1NF first and that all attributes <b>depend on the whole key</b>.
        </p>
        <h3>Depends on the Whole Key</h3>
        <p>
            If your primary keys do not contain any composite keys they your 1NF tables is in 2NF.
            This step is to normalise any composite primary key so attributes depend on the whole key.
            Note composite keys may span two or more attributes but should be minimal, which means
            it will not include attributes unless they're needed to uniquely identify a row.
        </p>
        <div class="eg">
            We've already listed all attributes in our table that depend on the primary key.
            We can see that ATTENDEES Age depends on Personal ID.
            However ATTENDEES has a composite primary key of (Personal ID, Event ID).
            Therefore our table is not in 2NF until we remove this attribute.
            If ATTENDEES has "attire" to store the attire worn by the person at the specified event.
            Then that would be okay as it depends on Personal ID and Event ID.<br/><br/>
            <img src="../assets/databases/2nf.jpg" alt="Example in 2NF"><br/><br/>
        </div>
        <h2>Third Normal Form (3NF)</h2>
        <p>
            This is the third step in normalisation.
            You must ensure it is in 2NF first and that all attributes <b>depend on nothing but the key</b>.
        </p>
        <h3>Depends on nothing but the key</h3>
        <p>
            We've looked at dependency on the key and whether it depends on the whole key.
            This aims to remove duplication where an attribute depends on a primary key but 
            has an additional dependency that is not the primary key.
        </p>
        <div class="eg">
            Oh dear our 2NF database is actually in 3NF!
            Thankfully our PEOPLE, EVENTS and UPDATES tables are far from extensive.
            Indeed one of the key considerations when storing data in a database is what
            you need to store.  For example a person is more than just a DoB, Name and Gender.
            We have lots of data we could store about a person.
            Do we need to know if a person has attribute eyes "dreamy blue" or hair "totally bold"?
            In this case I've opted to not store this.  I will keep it that way.
            But we will instead assume we want to store Home Address for our PEOPLE.<br/><br/>
            <img src="../assets/databases/3nf.jpg" alt="Example in 2NF to 3NF"><br/><br/>
            We can see that "Country" depends on both "Personal ID" (as it's their home country) and 
            "County" (as each country has a set of counties).
            We could have lazyily stored the address as a single text field if we did not want to query it.
            For example we could have put a "description" attribute that includes the
            "dreamy blue eyes and totally bold head". If we don't want to search for it then that would work.
            But it makes sense we may want to search for all of our current friends in a specific country or county.
        </div>
        <h3>The Normalisation Oath</h3>
        <div>
            Remember in 1NF I explained there was a reason we just say "Key" rather than "Primary Key".
            It's simply so we can get to the normalisation oath.
            Interesting facts:
            <ul>
                <li>
                    Normalisation can go further including 6NF!  
                    Which is more normalisation that you think as not all Normal Forms are numbered.
                    These deal with higher order concepts that you don't need for your exam.
                    Also note that they don't fit in with the Normalisation Oath.
                </li>
                <li>Edgar F Codd was the person who invented the concept of normalisation.</li>
            </ul>
            And so it's time, repeat the Normalisation Oath because all attributes must depend on:
            <blockquote><em>
                The Key, the whole Key, and nothing but the Key, so help me Codd!
            </blockquote></em>
            The above mneumonic is not mine but it very handy to help you remember how to normalise to 3NF.<br/><br/>
        </div>
    </main>
</body>
</html>